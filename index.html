<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <!-- <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> -->
    <meta http-equiv="Content-Security-Policy" content="block-all-mixed-content">
    <meta name="author" content="Jisdom Huang">
    <meta name="copyright" content="">
    <meta name="description" content="">
    <meta itemprop="name" content="">
    <meta itemprop="image" content="">
    <meta itemprop="description" content="">

    <meta property="og:title" content="FUTURE MUSEUM OF HOLY PIG">
    <meta property="og:url" content="">
    <meta property="og:image" content="">
    <meta property="fb:app_id" content="">
    <meta property="og:description" content="">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="style.css" type="text/css" />
    <!-- <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico"> -->
    <!-- <script src="./anime.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.0.1/lib/anime.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <!-- <script src="index.js" type="text/javascript"></script> -->
    <link href="https://fonts.googleapis.com/css?family=Droid+Sans" rel="stylesheet">
    <title>FUTURE MUSEUM OF HOLY PIG</title>
    <!-- Polyfills -->
    <!--[if lt IE 10]>
    <script src="https://as.alipayobjects.com/g/component/??console-polyfill/0.2.2/index.js,es5-shim/4.5.7/es5-shim.min.js,es5-shim/4.5.7/es5-sham.min.js,es6-shim/0.35.1/es6-sham.min.js,es6-shim/0.35.1/es6-shim.min.js,html5shiv/3.7.2/html5shiv.min.js,media-match/2.0.2/media.match.min.js"></script>
   <![endif]-->
    <!--[if lte IE 11]>
    <script src="https://as.alipayobjects.com/g/component/??es6-shim/0.35.1/es6-sham.min.js,es6-shim/0.35.1/es6-shim.min.js"></script>
   <![endif]-->
</head>

<body>
    <div class="indexBG absolute">
        <div class="indexGrid">
            <div class="indexFlex">
                <div id="enterAni1">

                    <a href="archive.html" class="arrowbtn4" id="arrowbtn4"></a>
                    <div class="info1" id="info3">
                        本館研究團隊在長期的調查與研究中，已經逐步掌握三個平行世界的相關資料，並透過新型多時空展示系統的開發，觀眾可以同步看到在三個平行世界下的各種神豬飼養系統、科技的發展、該宗教文化的演化與蛻變。目前本館仍然在積極地找尋其他平行世界的神豬文化的軌跡，目標持續擴增館藏跟展覽空間，希望可以帶給觀眾更多不同神豬文化發展的故事與歷程。
                    </div>

                    <a href="javascript:;" class="arrowbtn3" id="arrowbtn3" onclick="clickd(this)"></a>
                    <div class="info1" id="info2">
                        西元2020年由於非洲豬瘟疫情爆發，全球豬隻在數年內逐步面臨物種滅絕的困境，同時也巨幅影響畜牧業的產業結構。在大環境的變遷之中，台灣傳統信仰中的神豬祭祀文化也受到疫情的嚴重影響。就在這數十年間，世界發展的走向裂解出數個平行世界，各個平行世界在非洲豬瘟疫情的不同發展下也產生了巨大的差異。台灣神豬文化在這有如蝴蝶效應的作用之下，在不同平行世界中也開展了神豬飼養、祭祀的多元差異。
                    </div>

                    <a href="javascript:;" class="arrowbtn2" id="arrowbtn2" onclick="clickc(this)"></a>
                    <div class="info1" id="info1">
                        本館透過平行世界展示系統的開發，展演數個不同平行世界下的台灣神豬文化。透過展示文史資料的檔案文件、神豬飼養系統的科技裝置、專家學者的訪談影像，帶領參觀者體驗不同平行世界中每種不同神豬文化的發展過程，並藉此瞭解此宗教文化與人類科技發展和自然環境的互動關係。
                    </div>

                    <a href="javascript:;" class="arrowbtn" id="arrowbtn" onclick="clickb(this)"></a>
                    <div class="p17">
                        <div class="introTitle" id="introTitle">
                            FUTURE MUSEUM<br />OF HOLY PIG
                        </div>
                    </div>
                </div>
            </div>

            <div id="aniWRAP">
                <a class="slogan" onclick="clicka(this)">
                    <div class="aniText">
                        <div class="text"></div>
                        <div class="text2"></div>
                        <div class="text3"></div>
                        <div class="text4"></div>
                        <div class="text5"></div>
                        <div class="text6"></div>
                        <div class="text7"></div>
                        <div class="text8"></div>
                        <div class="text9"></div>
                        <div class="text10"></div>
                        <div class="text11"></div>
                        <div class="text12"></div>
                        <div class="text13"></div>
                        <div class="text14"></div>
                        <div class="text15"></div>
                        <div class="text16"></div>
                        <div class="text17"></div>
                        <div class="text18"></div>
                        <div class="text19"></div>
                        <div class="text20"></div>
                        <div class="text21"></div>
                        <div class="text22"></div>
                        <div class="text23"></div>
                        <div class="text24"></div>
                        <div class="text25"></div>
                        <div class="text26"></div>
                        <div class="text27"></div>
                        <div class="text28"></div>
                        <div class="text29"></div>
                        <div class="text30"></div>
                        <div class="text31"></div>
                        <div class="text32"></div>
                        <div class="text33"></div>
                        <div class="text34"></div>
                        <div class="text35"></div>
                        <div class="text36"></div>
                        <div class="text37"></div>
                        <div class="text38"></div>
                        <div class="text39"></div>
                        <div class="text40"></div>
                        <div class="text41"></div>
                        <div class="text42"></div>
                        <div class="text43"></div>
                        <div class="text44"></div>
                        <div class="text45"></div>
                        <div class="text46"></div>
                        <div class="text47"></div>
                        <div class="text48"></div>
                        <div class="text49"></div>
                        <div class="text50"></div>
                        <div class="text51"></div>
                        <div class="text52"></div>
                        <div class="text53"></div>
                        <div class="text54"></div>
                        <div class="text55"></div>
                        <div class="text56"></div>
                        <div class="text57"></div>
                        <div class="text58"></div>
                        <div class="text59"></div>
                        <div class="text60"></div>
                        <div class="text61"></div>
                        <div class="text62"></div>
                        <div class="text63"></div>
                        <div class="text64"></div>
                        <div class="text65"></div>
                        <div class="text66"></div>
                        <div class="text67"></div>
                        <div class="text68"></div>
                    </div>
                </a>

            </div>

        </div>
    </div>
</body>
<script>

    // function hideLoadingDiv() {
    //     setTimeout(function () {
    //         document.getElementById('aniBox').classList.add('hidden');
    //     }, 4000)
    // }
    // hideLoadingDiv()

    function clickb(obj) {
        var info1 = document.getElementById("info1");
        info1.classList.add("show1");
        var hideTitle = document.getElementById("introTitle");
        hideTitle.classList.add("opacity0");
        var enterAni1opacity = document.getElementById("enterAni1");
        enterAni1opacity.classList.add("opacity40");
        var hidearrowbtn = document.getElementById("arrowbtn");
        hidearrowbtn.classList.add("hidden");
        document.getElementById("arrowbtn2").classList.add("showbtn");

    }

    function clickc(obj) {
        var info2 = document.getElementById("info2");
        info2.classList.add("show2");
        document.getElementById("info1").classList.add("hidden");
        document.getElementById("arrowbtn2").classList.add("hidden");
        document.getElementById("arrowbtn3").classList.add("showbtn");

    }

    function clickd(obj) {
        document.getElementById("info3").classList.add("show3");
        document.getElementById("info2").classList.add("hidden");
        document.getElementById("arrowbtn3").classList.add("hidden");
        document.getElementById("arrowbtn4").classList.add("show4");
        document.getElementById("arrowbtn4").style.display = "block";
    }




    class TextScramble {
        constructor(el) {
            this.el = el
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases = [
        'A',
        '9',
        'C',
        '褒',
        'I',
        '特',
        '1'

    ]

    const el = document.querySelector('.text')
    const fx = new TextScramble(el)

    let counter = 0
    const next = () => {
        fx.setText(phrases[counter]).then(() => {
            setTimeout(next, 1800)
        })
        counter = (counter + 1) % phrases.length
    }

    next()



    class TextScramble2 {
        constructor(el2) {
            this.el2 = el2
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el2.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el2.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases2 = [
        '8',
        'a',
        '醮',
        '1',
        'I',
        'J',
        '舍'
    ]

    const el2 = document.querySelector('.text2')
    const fx2 = new TextScramble2(el2)

    let counter2 = 0
    const next2 = () => {
        fx2.setText(phrases2[counter2]).then(() => {
            setTimeout(next2, 3000)
        })
        counter2 = (counter2 + 1) % phrases2.length
    }

    next2()


    class TextScramble3 {
        constructor(el3) {
            this.el3 = el3
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el3.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el3.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases3 = [
        's',
        'K',
        'K',
        'q',
        '9',
        '黑',
        'L'
    ]

    const el3 = document.querySelector('.text3')
    const fx3 = new TextScramble3(el3)

    let counter3 = 0
    const next3 = () => {
        fx3.setText(phrases3[counter3]).then(() => {
            setTimeout(next3, 2100)
        })
        counter3 = (counter3 + 1) % phrases3.length
    }

    next3()

    class TextScramble4 {
        constructor(el4) {
            this.el4 = el4
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el4.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el4.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases4 = [
        'i',
        '花',
        'Q',
        'A',
        '7',
        '羊',
        '1'
    ]

    const el4 = document.querySelector('.text4')
    const fx4 = new TextScramble4(el4)

    let counter4 = 0
    const next4 = () => {
        fx4.setText(phrases4[counter4]).then(() => {
            setTimeout(next4, 3000)
        })
        counter4 = (counter4 + 1) % phrases4.length
    }

    next4()

    class TextScramble5 {
        constructor(el5) {
            this.el5 = el5
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el5.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el5.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases5 = [
        'l',
        'o',
        'S',
        '8',
        '磅',
        'k',
        'a'
    ]

    const el5 = document.querySelector('.text5')
    const fx5 = new TextScramble5(el5)

    let counter5 = 0
    const next5 = () => {
        fx5.setText(phrases5[counter5]).then(() => {
            setTimeout(next5, 3000)
        })
        counter5 = (counter5 + 1) % phrases5.length
    }

    next5()

    class TextScramble6 {
        constructor(el6) {
            this.el6 = el6
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el6.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el6.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases6 = [
        'j',
        'k',
        '5',
        'f',
        '涼',
        '8',
        '糰'
    ]

    const el6 = document.querySelector('.text6')
    const fx6 = new TextScramble6(el6)

    let counter6 = 0
    const next6 = () => {
        fx6.setText(phrases6[counter6]).then(() => {
            setTimeout(next6, 1300)
        })
        counter6 = (counter6 + 1) % phrases6.length
    }

    next6()

    class TextScramble7 {
        constructor(el7) {
            this.el7 = el7
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el7.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el7.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases7 = [
        's',
        'O',
        'C',
        '4',
        'Q',
        '床',
        'm'
    ]

    const el7 = document.querySelector('.text7')
    const fx7 = new TextScramble7(el7)

    let counter7 = 0
    const next7 = () => {
        fx7.setText(phrases7[counter7]).then(() => {
            setTimeout(next7, 4400)
        })
        counter7 = (counter7 + 1) % phrases7.length
    }

    next7()

    class TextScramble8 {
        constructor(el8) {
            this.el8 = el8
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el8.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el8.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases8 = [
        'C',
        'S',
        '7',
        '抓',
        'H',
        '@',
        '領'
    ]

    const el8 = document.querySelector('.text8')
    const fx8 = new TextScramble8(el8)

    let counter8 = 0
    const next8 = () => {
        fx8.setText(phrases8[counter8]).then(() => {
            setTimeout(next8, 1300)
        })
        counter8 = (counter8 + 1) % phrases8.length
    }

    next8()

    class TextScramble9 {
        constructor(el9) {
            this.el9 = el9
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el9.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el9.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases9 = [
        '渡',
        'K',
        '1',
        '9',
        '元',
        'X',
        'z'
    ]

    const el9 = document.querySelector('.text9')
    const fx9 = new TextScramble9(el9)

    let counter9 = 0
    const next9 = () => {
        fx9.setText(phrases9[counter9]).then(() => {
            setTimeout(next9, 1700)
        })
        counter9 = (counter9 + 1) % phrases9.length
    }

    next9()


    class TextScramble10 {
        constructor(el10) {
            this.el10 = el10
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el10.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el10.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases10 = [
        'K',
        'J',
        'M',
        '4',
        'G',
        '發',
        'A'
    ]

    const el10 = document.querySelector('.text10')
    const fx10 = new TextScramble10(el10)

    let counter10 = 0
    const next10 = () => {
        fx10.setText(phrases10[counter10]).then(() => {
            setTimeout(next10, 1200)
        })
        counter10 = (counter10 + 1) % phrases10.length
    }

    next10()


    class TextScramble11 {
        constructor(el11) {
            this.el11 = el11
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el11.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el11.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases11 = [
        'n',
        '1',
        'K',
        'G',
        'A',
        '7',
        'k'
    ]

    const el11 = document.querySelector('.text11')
    const fx11 = new TextScramble11(el11)

    let counter11 = 0
    const next11 = () => {
        fx11.setText(phrases11[counter11]).then(() => {
            setTimeout(next11, 2200)
        })
        counter11 = (counter11 + 1) % phrases11.length
    }

    next11()


    class TextScramble12 {
        constructor(el12) {
            this.el12 = el12
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el12.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el12.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases12 = [
        'm',
        'A',
        '紅',
        'K',
        '9',
        'H',
        'J'
    ]

    const el12 = document.querySelector('.text12')
    const fx12 = new TextScramble12(el12)

    let counter12 = 0
    const next12 = () => {
        fx12.setText(phrases12[counter12]).then(() => {
            setTimeout(next12, 2200)
        })
        counter12 = (counter12 + 1) % phrases12.length
    }

    next12()


    class TextScramble13 {
        constructor(el13) {
            this.el13 = el13
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el13.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el13.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases13 = [
        '翻',
        '黑',
        'A',
        '8',
        'K',
        'q',
        'l'
    ]

    const el13 = document.querySelector('.text13')
    const fx13 = new TextScramble13(el13)

    let counter13 = 0
    const next13 = () => {
        fx13.setText(phrases13[counter13]).then(() => {
            setTimeout(next13, 2200)
        })
        counter13 = (counter13 + 1) % phrases13.length
    }

    next13()

    class TextScramble14 {
        constructor(el14) {
            this.el14 = el14
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el14.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el14.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases14 = [
        'm',
        'Q',
        's',
        '特',
        '1',
        'O',
        '舍'
    ]

    const el14 = document.querySelector('.text14')
    const fx14 = new TextScramble14(el14)

    let counter14 = 0
    const next14 = () => {
        fx14.setText(phrases14[counter14]).then(() => {
            setTimeout(next14, 3200)
        })
        counter14 = (counter14 + 1) % phrases14.length
    }

    next14()

    class TextScramble15 {
        constructor(el15) {
            this.el15 = el15
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el15.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el15.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases15 = [
        '羊',
        'A',
        'l',
        '1',
        'k',
        '9',
        'f'
    ]

    const el15 = document.querySelector('.text15')
    const fx15 = new TextScramble15(el15)

    let counter15 = 0
    const next15 = () => {
        fx15.setText(phrases15[counter15]).then(() => {
            setTimeout(next15, 2000)
        })
        counter15 = (counter15 + 1) % phrases15.length
    }

    next15()


    class TextScramble16 {
        constructor(el16) {
            this.el16 = el16
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el16.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el16.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases16 = [
        'g',
        'O',
        '7',
        'x',
        '4',
        'K',
        's'
    ]

    const el16 = document.querySelector('.text16')
    const fx16 = new TextScramble16(el16)

    let counter16 = 0
    const next16 = () => {
        fx16.setText(phrases16[counter16]).then(() => {
            setTimeout(next16, 2000)
        })
        counter16 = (counter16 + 1) % phrases16.length
    }

    next16()


    class TextScramble17 {
        constructor(el17) {
            this.el17 = el17
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el17.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el17.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases17 = [
        'H',
        '磅',
        'l',
        '9',
        'Z',
        '糰',
        'A'
    ]

    const el17 = document.querySelector('.text17')
    const fx17 = new TextScramble17(el17)

    let counter17 = 0
    const next17 = () => {
        fx17.setText(phrases17[counter17]).then(() => {
            setTimeout(next17, 2000)
        })
        counter17 = (counter17 + 1) % phrases17.length
    }

    next17()


    class TextScramble18 {
        constructor(el18) {
            this.el18 = el18
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el18.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el18.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases18 = [
        'X',
        'Z',
        '0',
        '褒',
        'm',
        '醮',
        'T'
    ]

    const el18 = document.querySelector('.text18')
    const fx18 = new TextScramble18(el18)

    let counter18 = 0
    const next18 = () => {
        fx18.setText(phrases18[counter18]).then(() => {
            setTimeout(next18, 1600)
        })
        counter18 = (counter18 + 1) % phrases18.length
    }

    next18()


    class TextScramble19 {
        constructor(el19) {
            this.el19 = el19
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el19.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el19.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases19 = [
        'L',
        'T',
        'a',
        'U',
        'V',
        '4',
        'J'
    ]

    const el19 = document.querySelector('.text19')
    const fx19 = new TextScramble19(el19)

    let counter19 = 0
    const next19 = () => {
        fx19.setText(phrases19[counter19]).then(() => {
            setTimeout(next19, 3200)
        })
        counter19 = (counter19 + 1) % phrases19.length
    }

    next19()

    class TextScramble20 {
        constructor(el20) {
            this.el20 = el20
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el20.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el20.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases20 = [
        'V',
        'P',
        'B',
        '7',
        'K',
        '7',
        'V'
    ]

    const el20 = document.querySelector('.text20')
    const fx20 = new TextScramble20(el20)

    let counter20 = 0
    const next20 = () => {
        fx20.setText(phrases20[counter20]).then(() => {
            setTimeout(next20, 700)
        })
        counter20 = (counter20 + 1) % phrases20.length
    }

    next20()




    class TextScramble21 {
        constructor(el21) {
            this.el21 = el21
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el21.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el21.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases21 = [
        'A',
        '9',
        'C',
        '花',
        'I',
        'Q',
        '1'

    ]

    const el21 = document.querySelector('.text21')
    const fx21 = new TextScramble21(el21)

    let counter21 = 0
    const next21 = () => {
        fx21.setText(phrases21[counter21]).then(() => {
            setTimeout(next21, 1800)
        })
        counter21 = (counter21 + 1) % phrases21.length
    }

    next21()



    class TextScramble22 {
        constructor(el22) {
            this.el22 = el22
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el22.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el22.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases22 = [
        '8',
        'a',
        '床',
        '1',
        'I',
        'J',
        '3'
    ]

    const el22 = document.querySelector('.text22')
    const fx22 = new TextScramble22(el22)

    let counter22 = 0
    const next22 = () => {
        fx22.setText(phrases22[counter22]).then(() => {
            setTimeout(next22, 3000)
        })
        counter22 = (counter22 + 1) % phrases22.length
    }

    next22()


    class TextScramble23 {
        constructor(el23) {
            this.el23 = el23
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el23.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el23.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases23 = [
        's',
        'K',
        'K',
        'q',
        '9',
        '領',
        'L'
    ]

    const el23 = document.querySelector('.text23')
    const fx23 = new TextScramble23(el23)

    let counter23 = 0
    const next23 = () => {
        fx23.setText(phrases23[counter23]).then(() => {
            setTimeout(next23, 2100)
        })
        counter23 = (counter23 + 1) % phrases23.length
    }

    next23()

    class TextScramble24 {
        constructor(el24) {
            this.el24 = el24
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el24.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el24.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases24 = [
        'i',
        '元',
        'Q',
        'A',
        '7',
        '發',
        '1'
    ]

    const el24 = document.querySelector('.text24')
    const fx24 = new TextScramble24(el24)

    let counter24 = 0
    const next24 = () => {
        fx24.setText(phrases24[counter24]).then(() => {
            setTimeout(next24, 3000)
        })
        counter24 = (counter24 + 1) % phrases24.length
    }

    next24()

    class TextScramble25 {
        constructor(el25) {
            this.el25 = el25
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el25.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el25.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases25 = [
        'l',
        'o',
        'S',
        '8',
        '特',
        'k',
        'a'
    ]

    const el25 = document.querySelector('.text25')
    const fx25 = new TextScramble25(el25)

    let counter25 = 0
    const next25 = () => {
        fx25.setText(phrases25[counter25]).then(() => {
            setTimeout(next25, 3000)
        })
        counter25 = (counter25 + 1) % phrases25.length
    }

    next25()

    class TextScramble26 {
        constructor(el26) {
            this.el26 = el26
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el26.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el26.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases26 = [
        'j',
        'k',
        '5',
        'f',
        '舍',
        '8',
        '涼'
    ]

    const el26 = document.querySelector('.text26')
    const fx26 = new TextScramble6(el26)

    let counter26 = 0
    const next26 = () => {
        fx26.setText(phrases26[counter26]).then(() => {
            setTimeout(next26, 1300)
        })
        counter26 = (counter26 + 1) % phrases26.length
    }

    next26()

    class TextScramble27 {
        constructor(el27) {
            this.el27 = el27
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el27.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el27.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases27 = [
        's',
        'O',
        'C',
        '4',
        'Q',
        '領',
        'm'
    ]

    const el27 = document.querySelector('.text27')
    const fx27 = new TextScramble27(el27)

    let counter27 = 0
    const next27 = () => {
        fx27.setText(phrases27[counter27]).then(() => {
            setTimeout(next27, 4400)
        })
        counter27 = (counter27 + 1) % phrases27.length
    }

    next27()

    class TextScramble28 {
        constructor(el28) {
            this.el28 = el28
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el28.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el28.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases28 = [
        'C',
        'S',
        '7',
        '渡',
        'H',
        '@',
        '翻'
    ]

    const el28 = document.querySelector('.text28')
    const fx28 = new TextScramble8(el28)

    let counter28 = 0
    const next28 = () => {
        fx28.setText(phrases28[counter28]).then(() => {
            setTimeout(next28, 1300)
        })
        counter28 = (counter28 + 1) % phrases28.length
    }

    next28()

    class TextScramble29 {
        constructor(el29) {
            this.el29 = el29
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el29.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el29.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases29 = [
        'J',
        'K',
        '1',
        '9',
        '特',
        'X',
        'z'
    ]

    const el29 = document.querySelector('.text29')
    const fx29 = new TextScramble29(el29)

    let counter29 = 0
    const next29 = () => {
        fx29.setText(phrases29[counter29]).then(() => {
            setTimeout(next29, 1700)
        })
        counter29 = (counter29 + 1) % phrases29.length
    }

    next29()


    class TextScramble30 {
        constructor(el30) {
            this.el30 = el30
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el30.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el30.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases30 = [
        'K',
        'J',
        'M',
        '4',
        'G',
        '抓',
        'A'
    ]

    const el30 = document.querySelector('.text30')
    const fx30 = new TextScramble30(el30)

    let counter30 = 0
    const next30 = () => {
        fx30.setText(phrases30[counter30]).then(() => {
            setTimeout(next30, 1200)
        })
        counter30 = (counter30 + 1) % phrases30.length
    }

    next30()


    class TextScramble31 {
        constructor(el31) {
            this.el31 = el31
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el31.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el31.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases31 = [
        'n',
        '1',
        'K',
        'G',
        'A',
        '7',
        'k'
    ]

    const el31 = document.querySelector('.text31')
    const fx31 = new TextScramble31(el31)

    let counter31 = 0
    const next31 = () => {
        fx31.setText(phrases31[counter31]).then(() => {
            setTimeout(next31, 2200)
        })
        counter31 = (counter31 + 1) % phrases31.length
    }

    next31()


    class TextScramble32 {
        constructor(el32) {
            this.el32 = el32
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el32.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el32.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases32 = [
        'm',
        'A',
        '羊',
        'K',
        '9',
        'H',
        'J'
    ]

    const el32 = document.querySelector('.text32')
    const fx32 = new TextScramble32(el32)

    let counter32 = 0
    const next32 = () => {
        fx32.setText(phrases32[counter32]).then(() => {
            setTimeout(next32, 2200)
        })
        counter32 = (counter32 + 1) % phrases32.length
    }

    next32()


    class TextScramble33 {
        constructor(el33) {
            this.el33 = el33
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el33.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el33.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases33 = [
        '糰',
        '羊',
        'A',
        '8',
        'K',
        'q',
        'l'
    ]

    const el33 = document.querySelector('.text33')
    const fx33 = new TextScramble33(el33)

    let counter33 = 0
    const next33 = () => {
        fx33.setText(phrases33[counter33]).then(() => {
            setTimeout(next33, 2200)
        })
        counter33 = (counter33 + 1) % phrases33.length
    }

    next33()

    class TextScramble34 {
        constructor(el34) {
            this.el34 = el34
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el34.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el34.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases34 = [
        'm',
        'Q',
        's',
        '特',
        '1',
        'O',
        '褒'
    ]

    const el34 = document.querySelector('.text34')
    const fx34 = new TextScramble14(el34)

    let counter34 = 0
    const next34 = () => {
        fx34.setText(phrases34[counter34]).then(() => {
            setTimeout(next34, 3200)
        })
        counter34 = (counter34 + 1) % phrases34.length
    }

    next34()

    class TextScramble35 {
        constructor(el35) {
            this.el35 = el35
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el35.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el35.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases35 = [
        '涼',
        'A',
        'l',
        '1',
        'k',
        '9',
        'f'
    ]

    const el35 = document.querySelector('.text35')
    const fx35 = new TextScramble35(el35)

    let counter35 = 0
    const next35 = () => {
        fx35.setText(phrases35[counter35]).then(() => {
            setTimeout(next35, 2000)
        })
        counter35 = (counter35 + 1) % phrases35.length
    }

    next35()


    class TextScramble36 {
        constructor(el36) {
            this.el36 = el36
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el36.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el36.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases36 = [
        'g',
        'O',
        '7',
        'x',
        '4',
        'K',
        's'
    ]

    const el36 = document.querySelector('.text36')
    const fx36 = new TextScramble36(el36)

    let counter36 = 0
    const next36 = () => {
        fx36.setText(phrases36[counter36]).then(() => {
            setTimeout(next36, 2000)
        })
        counter36 = (counter36 + 1) % phrases36.length
    }

    next36()


    class TextScramble37 {
        constructor(el37) {
            this.el37 = el37
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el37.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el37.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases37 = [
        'H',
        '抓',
        'l',
        '9',
        'Z',
        '領',
        'A'
    ]

    const el37 = document.querySelector('.text37')
    const fx37 = new TextScramble37(el37)

    let counter37 = 0
    const next37 = () => {
        fx37.setText(phrases37[counter37]).then(() => {
            setTimeout(next37, 2000)
        })
        counter37 = (counter37 + 1) % phrases37.length
    }

    next37()


    class TextScramble38 {
        constructor(el38) {
            this.el38 = el38
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el38.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el38.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases38 = [
        'X',
        'Z',
        '0',
        '渡',
        'm',
        '發',
        'T'
    ]

    const el38 = document.querySelector('.text38')
    const fx38 = new TextScramble16(el38)

    let counter38 = 0
    const next38 = () => {
        fx38.setText(phrases38[counter38]).then(() => {
            setTimeout(next38, 1600)
        })
        counter38 = (counter38 + 1) % phrases38.length
    }

    next38()


    class TextScramble39 {
        constructor(el39) {
            this.el39 = el39
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el39.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el39.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases39 = [
        'L',
        'T',
        'a',
        'U',
        'V',
        '4',
        'J'
    ]

    const el39 = document.querySelector('.text39')
    const fx39 = new TextScramble39(el39)

    let counter39 = 0
    const next39 = () => {
        fx39.setText(phrases39[counter39]).then(() => {
            setTimeout(next39, 3200)
        })
        counter39 = (counter39 + 1) % phrases39.length
    }

    next39()

    class TextScramble40 {
        constructor(el40) {
            this.el40 = el40
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el40.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el40.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases40 = [
        'V',
        'P',
        'B',
        '7',
        'K',
        '7',
        'V'
    ]

    const el40 = document.querySelector('.text40')
    const fx40 = new TextScramble40(el40)

    let counter40 = 0
    const next40 = () => {
        fx40.setText(phrases40[counter40]).then(() => {
            setTimeout(next40, 700)
        })
        counter40 = (counter40 + 1) % phrases40.length
    }

    next40()



    class TextScramble41 {
        constructor(el41) {
            this.el41 = el41
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el41.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el41.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases41 = [
        'n',
        '1',
        'K',
        'G',
        'A',
        '7',
        'k'
    ]

    const el41 = document.querySelector('.text41')
    const fx41 = new TextScramble41(el41)

    let counter41 = 0
    const next41 = () => {
        fx41.setText(phrases41[counter41]).then(() => {
            setTimeout(next41, 2200)
        })
        counter41 = (counter41 + 1) % phrases41.length
    }

    next41()


    class TextScramble42 {
        constructor(el42) {
            this.el42 = el42
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el42.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el42.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases42 = [
        'm',
        'A',
        '羊',
        'K',
        '9',
        'H',
        'J'
    ]

    const el42 = document.querySelector('.text42')
    const fx42 = new TextScramble42(el42)

    let counter42 = 0
    const next42 = () => {
        fx42.setText(phrases42[counter42]).then(() => {
            setTimeout(next42, 2200)
        })
        counter42 = (counter42 + 1) % phrases42.length
    }

    next42()


    class TextScramble43 {
        constructor(el43) {
            this.el43 = el43
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el43.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el43.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases43 = [
        '糰',
        '羊',
        'A',
        '8',
        'K',
        'q',
        'l'
    ]

    const el43 = document.querySelector('.text43')
    const fx43 = new TextScramble43(el43)

    let counter43 = 0
    const next43 = () => {
        fx43.setText(phrases43[counter43]).then(() => {
            setTimeout(next43, 2200)
        })
        counter43 = (counter43 + 1) % phrases43.length
    }

    next43()

    class TextScramble44 {
        constructor(el44) {
            this.el44 = el44
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el44.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el44.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases44 = [
        'm',
        'Q',
        's',
        '特',
        '1',
        'O',
        '褒'
    ]

    const el44 = document.querySelector('.text44')
    const fx44 = new TextScramble44(el44)

    let counter44 = 0
    const next44 = () => {
        fx44.setText(phrases44[counter44]).then(() => {
            setTimeout(next44, 3200)
        })
        counter44 = (counter44 + 1) % phrases44.length
    }

    next44()

    class TextScramble45 {
        constructor(el45) {
            this.el45 = el45
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el45.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el45.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases45 = [
        '涼',
        'A',
        'l',
        '1',
        'k',
        '9',
        'f'
    ]

    const el45 = document.querySelector('.text45')
    const fx45 = new TextScramble45(el45)

    let counter45 = 0
    const next45 = () => {
        fx45.setText(phrases45[counter45]).then(() => {
            setTimeout(next45, 2000)
        })
        counter45 = (counter45 + 1) % phrases45.length
    }

    next45()


    class TextScramble46 {
        constructor(el46) {
            this.el46 = el46
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el46.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el46.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases46 = [
        'g',
        'O',
        '7',
        'x',
        '4',
        'K',
        's'
    ]

    const el46 = document.querySelector('.text46')
    const fx46 = new TextScramble46(el46)

    let counter46 = 0
    const next46 = () => {
        fx46.setText(phrases46[counter46]).then(() => {
            setTimeout(next46, 2000)
        })
        counter46 = (counter46 + 1) % phrases46.length
    }

    next46()


    class TextScramble47 {
        constructor(el47) {
            this.el47 = el47
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el47.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el47.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases47 = [
        'H',
        '抓',
        'l',
        '9',
        'Z',
        '領',
        'A'
    ]

    const el47 = document.querySelector('.text47')
    const fx47 = new TextScramble47(el47)

    let counter47 = 0
    const next47 = () => {
        fx47.setText(phrases47[counter47]).then(() => {
            setTimeout(next47, 2000)
        })
        counter47 = (counter47 + 1) % phrases47.length
    }

    next47()


    class TextScramble48 {
        constructor(el48) {
            this.el48 = el48
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el48.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el48.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases48 = [
        'X',
        'Z',
        '0',
        '渡',
        'm',
        '發',
        'T'
    ]

    const el48 = document.querySelector('.text48')
    const fx48 = new TextScramble48(el48)

    let counter48 = 0
    const next48 = () => {
        fx48.setText(phrases48[counter48]).then(() => {
            setTimeout(next48, 1600)
        })
        counter48 = (counter48 + 1) % phrases48.length
    }

    next48()


    class TextScramble49 {
        constructor(el49) {
            this.el49 = el49
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el49.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el49.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases49 = [
        'L',
        'T',
        'a',
        'U',
        'V',
        '4',
        'J'
    ]

    const el49 = document.querySelector('.text49')
    const fx49 = new TextScramble49(el49)

    let counter49 = 0
    const next49 = () => {
        fx49.setText(phrases49[counter49]).then(() => {
            setTimeout(next49, 3200)
        })
        counter49 = (counter49 + 1) % phrases49.length
    }

    next49()

    class TextScramble50 {
        constructor(el50) {
            this.el50 = el50
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el50.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el50.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases50 = [
        'V',
        'P',
        'B',
        '7',
        'K',
        '7',
        'V'
    ]

    const el50 = document.querySelector('.text50')
    const fx50 = new TextScramble50(el50)

    let counter50 = 0
    const next50 = () => {
        fx50.setText(phrases50[counter50]).then(() => {
            setTimeout(next50, 700)
        })
        counter50 = (counter50 + 1) % phrases50.length
    }

    next50()


    class TextScramble51 {
        constructor(el51) {
            this.el51 = el51
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el51.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el51.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases51 = [
        'n',
        '1',
        'K',
        'G',
        'A',
        '7',
        'k'
    ]

    const el51 = document.querySelector('.text51')
    const fx51 = new TextScramble51(el51)

    let counter51 = 0
    const next51 = () => {
        fx51.setText(phrases51[counter51]).then(() => {
            setTimeout(next51, 2200)
        })
        counter51 = (counter51 + 1) % phrases51.length
    }

    next51()


    class TextScramble52 {
        constructor(el52) {
            this.el52 = el52
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el52.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el52.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases52 = [
        'm',
        'A',
        '羊',
        'K',
        '9',
        'H',
        'J'
    ]

    const el52 = document.querySelector('.text52')
    const fx52 = new TextScramble52(el52)

    let counter52 = 0
    const next52 = () => {
        fx52.setText(phrases52[counter52]).then(() => {
            setTimeout(next52, 2200)
        })
        counter52 = (counter52 + 1) % phrases52.length
    }

    next52()


    class TextScramble53 {
        constructor(el53) {
            this.el53 = el53
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el53.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el53.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases53 = [
        '糰',
        '羊',
        'A',
        '8',
        'K',
        'q',
        'l'
    ]

    const el53 = document.querySelector('.text53')
    const fx53 = new TextScramble53(el53)

    let counter53 = 0
    const next53 = () => {
        fx53.setText(phrases53[counter53]).then(() => {
            setTimeout(next53, 2200)
        })
        counter53 = (counter53 + 1) % phrases53.length
    }

    next53()

    class TextScramble54 {
        constructor(el54) {
            this.el54 = el54
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el54.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el54.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases54 = [
        'm',
        'Q',
        's',
        '特',
        '1',
        'O',
        '褒'
    ]

    const el54 = document.querySelector('.text54')
    const fx54 = new TextScramble54(el54)

    let counter54 = 0
    const next54 = () => {
        fx54.setText(phrases54[counter54]).then(() => {
            setTimeout(next54, 3200)
        })
        counter54 = (counter54 + 1) % phrases54.length
    }

    next54()

    class TextScramble55 {
        constructor(el55) {
            this.el55 = el55
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el55.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el55.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases55 = [
        '涼',
        'A',
        'l',
        '1',
        'k',
        '9',
        'f'
    ]

    const el55 = document.querySelector('.text55')
    const fx55 = new TextScramble55(el55)

    let counter55 = 0
    const next55 = () => {
        fx55.setText(phrases55[counter55]).then(() => {
            setTimeout(next55, 2000)
        })
        counter55 = (counter55 + 1) % phrases55.length
    }

    next55()


    class TextScramble56 {
        constructor(el56) {
            this.el56 = el56
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el56.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el56.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases56 = [
        'g',
        'O',
        '7',
        'x',
        '4',
        'K',
        's'
    ]

    const el56 = document.querySelector('.text56')
    const fx56 = new TextScramble56(el56)

    let counter56 = 0
    const next56 = () => {
        fx56.setText(phrases56[counter56]).then(() => {
            setTimeout(next56, 2000)
        })
        counter56 = (counter56 + 1) % phrases56.length
    }

    next56()


    class TextScramble57 {
        constructor(el57) {
            this.el57 = el57
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el57.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el57.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases57 = [
        'H',
        '抓',
        'l',
        '9',
        'Z',
        '領',
        'A'
    ]

    const el57 = document.querySelector('.text57')
    const fx57 = new TextScramble57(el57)

    let counter57 = 0
    const next57 = () => {
        fx57.setText(phrases57[counter57]).then(() => {
            setTimeout(next57, 2000)
        })
        counter57 = (counter57 + 1) % phrases57.length
    }

    next57()


    class TextScramble58 {
        constructor(el58) {
            this.el58 = el58
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el58.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el58.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases58 = [
        'X',
        'Z',
        '0',
        '渡',
        'm',
        '發',
        'T'
    ]

    const el58 = document.querySelector('.text58')
    const fx58 = new TextScramble58(el58)

    let counter58 = 0
    const next58 = () => {
        fx58.setText(phrases58[counter58]).then(() => {
            setTimeout(next58, 1600)
        })
        counter58 = (counter58 + 1) % phrases58.length
    }

    next58()


    class TextScramble59 {
        constructor(el59) {
            this.el59 = el59
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el59.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el59.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases59 = [
        'L',
        'T',
        'a',
        'U',
        'V',
        '4',
        'J'
    ]

    const el59 = document.querySelector('.text59')
    const fx59 = new TextScramble59(el59)

    let counter59 = 0
    const next59 = () => {
        fx59.setText(phrases59[counter59]).then(() => {
            setTimeout(next59, 3200)
        })
        counter59 = (counter59 + 1) % phrases59.length
    }

    next59()

    class TextScramble60 {
        constructor(el60) {
            this.el60 = el60
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el60.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el60.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }


    const phrases60 = [
        '特',
        '褒',
        '醮',
        '舍',
        '黑',
        '花',
        '羊',
        '磅',
        '涼',
        '糰',
        '床',
        '抓',
        '領',
        '元',
        '渡',
        '發',
        '紅',
        '翻'
    ]

    const el60 = document.querySelector('.text60')
    const fx60 = new TextScramble60(el60)

    let counter60 = 0
    const next60 = () => {
        fx60.setText(phrases60[counter60]).then(() => {
            setTimeout(next60, 700)
        })
        counter60 = (counter60 + 1) % phrases60.length
    }

    next60()



    class TextScramble61 {
        constructor(el61) {
            this.el61 = el61
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el61.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el61.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases61 = [
        '!',
        '&',
        '*',
        '#',
        '$',
        '+',
        '=',
        '&'
    ]

    const el61 = document.querySelector('.text61')
    const fx61 = new TextScramble61(el61)

    let counter61 = 0
    const next61 = () => {
        fx61.setText(phrases61[counter61]).then(() => {
            setTimeout(next61, 1700)
        })
        counter61 = (counter61 + 1) % phrases61.length
    }

    next61()


    class TextScramble62 {
        constructor(el62) {
            this.el62 = el62
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el62.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el62.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases62 = [
        '&',
        '!',
        '&',
        '=',
        '#',
        '$',
        '+',
        '*'
    ]

    const el62 = document.querySelector('.text62')
    const fx62 = new TextScramble62(el62)

    let counter62 = 0
    const next62 = () => {
        fx62.setText(phrases62[counter62]).then(() => {
            setTimeout(next62, 1100)
        })
        counter62 = (counter62 + 1) % phrases62.length
    }

    next62()



    class TextScramble63 {
        constructor(el63) {
            this.el63 = el63
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el63.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el63.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases63 = [
        '$',
        '&',
        '!',
        '#',
        '*',
        '=',
        '+',
        '&'
    ]

    const el63 = document.querySelector('.text63')
    const fx63 = new TextScramble63(el63)

    let counter63 = 0
    const next63 = () => {
        fx63.setText(phrases63[counter63]).then(() => {
            setTimeout(next63, 700)
        })
        counter63 = (counter63 + 1) % phrases63.length
    }

    next63()



    class TextScramble64 {
        constructor(el64) {
            this.el64 = el64
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el64.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el64.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases64 = [
        '*',
        '$',
        '!',
        '#',
        '&',
        '+',
        '=',
        '&'
    ]

    const el64 = document.querySelector('.text64')
    const fx64 = new TextScramble64(el64)

    let counter64 = 0
    const next64 = () => {
        fx64.setText(phrases64[counter64]).then(() => {
            setTimeout(next64, 1200)
        })
        counter64 = (counter64 + 1) % phrases64.length
    }

    next64()



    class TextScramble65 {
        constructor(el65) {
            this.el65 = el65
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el65.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el65.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases65 = [
        '=',
        '&',
        '+',
        '*',
        '!',
        '$',
        '#',
        '&'
    ]

    const el65 = document.querySelector('.text65')
    const fx65 = new TextScramble65(el65)

    let counter65 = 0
    const next65 = () => {
        fx65.setText(phrases65[counter65]).then(() => {
            setTimeout(next65, 1400)
        })
        counter65 = (counter65 + 1) % phrases65.length
    }

    next65()




    class TextScramble66 {
        constructor(el66) {
            this.el66 = el66
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el66.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el66.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases66 = [
        '&',
        '*',
        '$',
        '#',
        '+',
        '=',
        '!',
        '&'
    ]

    const el66 = document.querySelector('.text66')
    const fx66 = new TextScramble66(el66)

    let counter66 = 0
    const next66 = () => {
        fx66.setText(phrases66[counter66]).then(() => {
            setTimeout(next66, 300)
        })
        counter66 = (counter66 + 1) % phrases66.length
    }

    next66()

    class TextScramble67 {
        constructor(el67) {
            this.el67 = el67
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el67.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el67.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases67 = [
        '*',
        '&',
        '=',
        '#',
        '$',
        '+',
        '!',
        '&'
    ]

    const el67 = document.querySelector('.text67')
    const fx67 = new TextScramble67(el67)

    let counter67 = 0
    const next67 = () => {
        fx67.setText(phrases67[counter67]).then(() => {
            setTimeout(next67, 1300)
        })
        counter67 = (counter67 + 1) % phrases67.length
    }

    next67()



    class TextScramble68 {
        constructor(el68) {
            this.el68 = el68
            this.chars = '!<>-_\\/[]{}—=+*^?#________'
            this.update = this.update.bind(this)
        }
        setText(newText) {
            const oldText = this.el68.innerText
            const length = Math.max(oldText.length, newText.length)
            const promise = new Promise((resolve) => this.resolve = resolve)
            this.queue = []
            for (let i = 0; i < length; i++) {
                const from = oldText[i] || ''
                const to = newText[i] || ''
                const start = Math.floor(Math.random() * 40)
                const end = start + Math.floor(Math.random() * 40)
                this.queue.push({ from, to, start, end })
            }
            cancelAnimationFrame(this.frameRequest)
            this.frame = 0
            this.update()
            return promise
        }
        update() {
            let output = ''
            let complete = 0
            for (let i = 0, n = this.queue.length; i < n; i++) {
                let { from, to, start, end, char } = this.queue[i]
                if (this.frame >= end) {
                    complete++
                    output += to
                } else if (this.frame >= start) {
                    if (!char || Math.random() < 0.28) {
                        char = this.randomChar()
                        this.queue[i].char = char
                    }
                    output += `<span class="dud">${char}</span>`
                } else {
                    output += from
                }
            }
            this.el68.innerHTML = output
            if (complete === this.queue.length) {
                this.resolve()
            } else {
                this.frameRequest = requestAnimationFrame(this.update)
                this.frame++
            }
        }
        randomChar() {
            return this.chars[Math.floor(Math.random() * this.chars.length)]
        }
    }



    const phrases68 = [
        '=',
        '!',
        '$',
        '#',
        '&',
        '+',
        '*',
        '&'
    ]

    const el68 = document.querySelector('.text68')
    const fx68 = new TextScramble68(el68)

    let counter68 = 0
    const next68 = () => {
        fx68.setText(phrases68[counter68]).then(() => {
            setTimeout(next68, 800)
        })
        counter68 = (counter68 + 1) % phrases68.length
    }

    next68()















    var p = document.querySelector('p');
    // p.innerHTML = p.innerHTML.replace(/(^|<\/?[^>]+>|\s+)([^\s<]+)/g, '$1<span>$2</span>');

    // p17.innerHTML = p17.innerHTML.replace(/(^|<\/?[^>]+>|\s+)([^\s<]+)/g, '$1<span>$2</span>');

    function clicka(obj) {
        var x = document.getElementById("aniWRAP");
        var an1 = document.getElementById("enterAni1");
        an1.classList.add("aniBox17");


        if (x.style.display === "none") {

        } else {
            x.style.display = "none";
            an1.style.opacity = 1;
            $('#enterAni1').addClass('show')
            $('#arrowbtn').addClass('anifadein')
            document.getElementById("arrowbtn4").style.display = "none";


        }
    }









</script>

</html>